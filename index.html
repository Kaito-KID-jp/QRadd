<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ 2</title>
    <style>
        /* CSSã¯å¤‰æ›´ãªã— */
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            font-size: 14px;
        }
        .container {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0;
        }
        .controls {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .preview {
            flex: 1;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            min-height: 0;
        }
        .preview canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .preview-message { color: #666; text-align: center; }
        label { font-weight: bold; }
        input[type="text"] {
            padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            width: 100%; box-sizing: border-box;
        }
        button, input[type="file"] {
            padding: 10px 15px; border: none; border-radius: 4px;
            cursor: pointer; font-size: 1em;
        }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .file-input-button { background-color: #007bff; color: white; display: inline-block; text-align: center; }
        #printButton { background-color: #28a745; color: white; }
        #printButton:disabled { background-color: #6c757d; }
        .file-name { font-style: italic; color: #555; word-break: break-all; }
        .error-message { color: red; font-weight: bold; margin-top: 10px; }
        .processing-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.7); display: flex;
            justify-content: center; align-items: center; font-size: 1.2em;
            z-index: 1000; cursor: wait;
        }
        .hidden { display: none; }
        .print-iframe { position: absolute; width: 0; height: 0; border: 0; left: -9999px; }
        .print-instruction {
            margin-top: 10px; padding: 10px; background-color: #fff3cd;
            border: 1px solid #ffeeba; color: #856404; border-radius: 4px;
        }
        #downloadGeneratedPdfLink {
            display: block; margin-top: 15px; padding: 10px; border: 1px solid blue;
            background-color: #e0e0ff; color: blue; text-decoration: none;
            text-align: center; border-radius: 4px;
        }
        #downloadGeneratedPdfLink:hover { background-color: #c0c0ff; }
    </style>
</head>
<body>
    <h1>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ 2</h1>
    <div class="container">
        <div class="controls">
            <div>
                <input type="file" id="pdfFile" accept=".pdf" class="hidden">
                <button type="button" class="file-input-button" onclick="document.getElementById('pdfFile').click();">ğŸ“‚ PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
                <p>é¸æŠä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«: <span id="fileName" class="file-name">ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ</span></p>
            </div>
            <div>
                <label for="lotNumber">âŒ¨ï¸ ãƒ­ãƒƒãƒˆç•ªå· :</label>
                <input type="text" id="lotNumber" pattern="^[a-zA-Z0-9\-]*$" title="åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿å…¥åŠ›å¯èƒ½ã§ã™">
            </div>
            <div>
                <button type="button" id="printButton" disabled>ğŸ–¨ï¸ å°åˆ· (QRã‚³ãƒ¼ãƒ‰è£é¢)</button>
                <p id="printInstruction" class="print-instruction hidden">
                    å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
                    <b>ã€Œä¸¡é¢å°åˆ·ã€</b>ã‚’é¸æŠã—ã€<b>ã€ŒçŸ­è¾ºã¨ã˜ (Flip on Short Edge / Top bind)ã€</b>ã«è¨­å®šã—ã¦å°åˆ·ã—ã¦ãã ã•ã„ã€‚
                </p>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>
        <div class="preview" id="previewArea">
            <p class="preview-message">PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
            <canvas id="pdfPreviewCanvas"></canvas>
        </div>
    </div>
    <div id="processingOverlay" class="processing-overlay hidden">
        <p>å‡¦ç†ä¸­...</p>
    </div>
    <iframe id="printIframe" class="print-iframe"></iframe>

    <!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>

    <script>
        // --- è¨­å®šå€¤ç­‰ (å¤‰æ›´ãªã—) ---
        const QR_PHYSICAL_SIZE_MM = 15;
        const QR_ERROR_CORRECTION_LEVEL = 'H';
        const PDF_POINTS_PER_MM = 72 / 25.4;
        const QR_SIZE_POINTS = QR_PHYSICAL_SIZE_MM * PDF_POINTS_PER_MM;
        const pdfFileInput = document.getElementById('pdfFile');
        const fileNameLabel = document.getElementById('fileName');
        const lotNumberInput = document.getElementById('lotNumber');
        const printButton = document.getElementById('printButton');
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('pdfPreviewCanvas');
        const previewMessage = previewArea.querySelector('.preview-message');
        const errorMessageDiv = document.getElementById('errorMessage');
        const processingOverlay = document.getElementById('processingOverlay');
        const printIframe = document.getElementById('printIframe');
        const printInstruction = document.getElementById('printInstruction');
        let selectedPdfFile = null;
        let originalPdfFileName = '';
        let currentObjectUrl = null;

        // --- åˆæœŸåŒ– (å¤‰æ›´ãªã—) ---
        function initialize() {
            const today = new Date();
            const year = String(today.getFullYear()).slice(-2);
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            lotNumberInput.value = `${year}-${month}-${day}`;
            pdfFileInput.addEventListener('change', handleFileSelect);
            lotNumberInput.addEventListener('input', validateLotNumber);
            printButton.addEventListener('click', handlePrint);
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => { if (selectedPdfFile) { displayPdfPreview(selectedPdfFile); } }, 250);
            });
        }

        // --- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå‡¦ç† (å¤‰æ›´ãªã—) ---
        async function handleFileSelect(event) {
            clearError();
            hidePrintInstruction();
            const existingLink = document.getElementById('downloadGeneratedPdfLink');
            if (existingLink) { existingLink.remove(); }
            const file = event.target.files[0];
            if (!file) {
                selectedPdfFile = null; fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ';
                printButton.disabled = true; clearPreview(); return;
            }
            if (file.type !== 'application/pdf') {
                showError('PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); selectedPdfFile = null;
                fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ'; printButton.disabled = true;
                clearPreview(); pdfFileInput.value = ''; return;
            }
            selectedPdfFile = file; originalPdfFileName = file.name;
            fileNameLabel.textContent = originalPdfFileName; printButton.disabled = false;
            showProcessing('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...');
            try { await displayPdfPreview(selectedPdfFile); }
            catch (error) {
                console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                showError(`PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                clearPreview(); printButton.disabled = true;
            } finally { hideProcessing(); }
        }

        // --- PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º (å¤‰æ›´ãªã—) ---
        async function displayPdfPreview(file) {
            const fileReader = new FileReader();
            fileReader.readAsArrayBuffer(file);
            return new Promise((resolve, reject) => {
                fileReader.onload = async (event) => {
                    const pdfData = new Uint8Array(event.target.result);
                    try {
                        const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                        const pdf = await loadingTask.promise;
                        if (pdf.numPages === 0) throw new Error('PDFã«ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 1.5 });
                        const canvasContext = previewCanvas.getContext('2d');
                        const containerWidth = previewArea.clientWidth;
                        const containerHeight = previewArea.clientHeight;
                        const scale = Math.min(containerWidth / viewport.width, containerHeight / viewport.height);
                        const scaledViewport = page.getViewport({ scale: scale * 0.95 });
                        previewCanvas.height = scaledViewport.height; previewCanvas.width = scaledViewport.width;
                        const renderContext = { canvasContext: canvasContext, viewport: scaledViewport };
                        await page.render(renderContext).promise;
                        previewMessage.classList.add('hidden'); previewCanvas.classList.remove('hidden');
                        resolve();
                    } catch (error) { console.error('PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error); reject(error); }
                };
                fileReader.onerror = (error) => { console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error); reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚')); };
           });
        }

        // --- clearPreview, validateLotNumber (å¤‰æ›´ãªã—) ---
        function clearPreview() {
            const context = previewCanvas.getContext('2d');
            context.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCanvas.classList.add('hidden');
            previewMessage.textContent = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„';
            previewMessage.classList.remove('hidden');
        }
        function validateLotNumber() {
            const lotNumber = lotNumberInput.value;
            const pattern = /^[a-zA-Z0-9\-]+$/;
            if (!pattern.test(lotNumber) && lotNumber !== '') { return false; }
            return pattern.test(lotNumberInput.value);
        }

        // --- å°åˆ·å‡¦ç† ---
        async function handlePrint() {
            if (!selectedPdfFile) { showError('ã¾ãšPDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); return; }
            const lotNumber = lotNumberInput.value;
            if (!/^[a-zA-Z0-9\-]+$/.test(lotNumber)) { showError('ãƒ­ãƒƒãƒˆç•ªå·ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ (åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ã€ç©ºæ¬„ä¸å¯)ã€‚'); return; }

            showProcessing('å›³å½¢æç”»ã¨PDFåŠ å·¥ä¸­...'); // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¤‰æ›´
            clearError();
            hidePrintInstruction();
            const existingLink = document.getElementById('downloadGeneratedPdfLink');
            if (existingLink) { existingLink.remove(); }

            try {
                // 1. QRã‚³ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ (æç”»ã¯ã—ãªã„ãŒã€å¾Œã®å‡¦ç†ã§ä½¿ã†å¯èƒ½æ€§ã‚’è€ƒæ…®ã—æ®‹ã™)
                const baseFileName = originalPdfFileName.replace(/\.[^/.]+$/, "");
                const firstPartFileName = baseFileName.split(' ')[0];
                const qrData = `FXQR,1,dn,1,#d#,fn,${firstPartFileName}_${lotNumber},hs,1,at,0,RQXF`;
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR Data:', qrData);

                // 2. QRã‚³ãƒ¼ãƒ‰ç”»åƒç”Ÿæˆ (æç”»ã¯ã—ãªã„ãŒã€å¾Œã®å‡¦ç†ã§ä½¿ã†å¯èƒ½æ€§ã‚’è€ƒæ…®ã—æ®‹ã™)
                // let qrCodeDataURL;
                // try { /* ... QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆå‡¦ç† ... */ } catch (qrError) { /* ... */ }

                // 3. å…ƒã®PDFèª­ã¿è¾¼ã¿
                const pdfBytes = await selectedPdfFile.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original PDF loaded. Pages:', pdfDoc.getPageCount());

                // 4. QRã‚³ãƒ¼ãƒ‰ç”»åƒã‚’åŸ‹ã‚è¾¼ã¿ç”¨ã«å¤‰æ› (ä»Šå›ã¯ä¸è¦ãªã®ã§ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ)
                // let qrImage;
                // try { /* ... ç”»åƒåŸ‹ã‚è¾¼ã¿å‡¦ç† ... */ } catch (embedError) { /* ... */ }

                // 5. æ–°ã—ã„PDFã‚’ä½œæˆã—ã€ãƒšãƒ¼ã‚¸ã¨å›³å½¢ã‚’è¿½åŠ 
                const newPdfDoc = await PDFLib.PDFDocument.create();
                const pageIndices = pdfDoc.getPageIndices();
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Calculated QR Size (points):', QR_SIZE_POINTS); // å‚è€ƒç”¨

                for (const pageIndex of pageIndices) {
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Processing page index: ${pageIndex}`);

                    const [originalPage] = await newPdfDoc.copyPages(pdfDoc, [pageIndex]);
                    newPdfDoc.addPage(originalPage);
                    const originalPageSize = originalPage.getSize();
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original page ${pageIndex + 1} (size: ${originalPageSize.width}x${originalPageSize.height}) copied.`);

                    const qrPage = newPdfDoc.addPage([originalPageSize.width, originalPageSize.height]);
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Blank page added for page ${pageIndex + 1}.`); // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¤‰æ›´

                    // ***** ã“ã“ã‹ã‚‰ãŒå¤‰æ›´ç‚¹ *****
                    // QRã‚³ãƒ¼ãƒ‰ã‚’æç”»ã™ã‚‹ä»£ã‚ã‚Šã«ã€å˜ç´”ãªå››è§’å½¢ã‚’æç”»ã—ã¦ã¿ã‚‹
                    try {
                         // ãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºå–å¾—
                        const pageSize = qrPage.getSize();
                        const pageWidth = pageSize.width;
                        const pageHeight = pageSize.height;

                        // â˜…â˜…â˜… å˜ç´”ãªå››è§’å½¢ã‚’æç”» â˜…â˜…â˜…
                        const rectSize = 100; // ãƒã‚¤ãƒ³ãƒˆå˜ä½
                        const rectX = (pageWidth - rectSize) / 2; // Xåº§æ¨™ä¸­å¤®
                        const rectY = (pageHeight - rectSize) / 2; // Yåº§æ¨™ä¸­å¤®
                        console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Drawing a RECTANGLE on page ${pageIndex + 1} at (${rectX.toFixed(2)}, ${rectY.toFixed(2)}) with size ${rectSize}x${rectSize}`);

                        qrPage.drawRectangle({
                            x: rectX,
                            y: rectY,
                            width: rectSize,
                            height: rectSize,
                            color: PDFLib.rgb(1, 0, 0), // èµ¤è‰² (R, G, B ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²)
                            // borderColor: PDFLib.rgb(0, 0, 1), // æ ç·šãŒå¿…è¦ãªã‚‰
                            // borderWidth: 3,
                        });
                         console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Rectangle drawn attempt finished for page ${pageIndex + 1}.`);

                    } catch (drawError) {
                         console.error(`Error drawing RECTANGLE on page ${pageIndex + 1}:`, drawError);
                         throw new Error(`å›³å½¢ã®æç”»ã«å¤±æ•—ã—ã¾ã—ãŸ (ãƒšãƒ¼ã‚¸ ${pageIndex + 1}): ${drawError.message}`);
                    }
                    // ***** ã“ã“ã¾ã§ãŒå¤‰æ›´ç‚¹ *****
                }

                // 6. åŠ å·¥æ¸ˆã¿PDFã‚’ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿å­˜
                const newPdfBytes = await newPdfDoc.save({ useObjectStreams: true });
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: New PDF saved to bytes. Size:', newPdfBytes.byteLength);

                // 7. Blobã¨Object URLã®ä½œæˆ
                const pdfBlob = new Blob([newPdfBytes], { type: 'application/pdf' });
                if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); }
                currentObjectUrl = URL.createObjectURL(pdfBlob);

                // 8. ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ä½œæˆ
                const downloadLink = document.createElement('a');
                downloadLink.id = 'downloadGeneratedPdfLink';
                downloadLink.href = currentObjectUrl;
                downloadLink.download = `rectangle_test_${originalPdfFileName}`; // ãƒ•ã‚¡ã‚¤ãƒ«åå¤‰æ›´
                downloadLink.textContent = 'ç”Ÿæˆã•ã‚ŒãŸPDF(å››è§’å½¢ãƒ†ã‚¹ãƒˆ)ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
                printButton.parentNode.insertBefore(downloadLink, printInstruction);
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Download link created for generated PDF (rectangle test).');

                // 9. éè¡¨ç¤ºiframeã§å°åˆ·
                let printJobPending = false;
                printIframe.onload = () => { /* ... (å¤‰æ›´ãªã—) ... */
                     if (printIframe.src && printIframe.src.startsWith('blob:') && printJobPending) {
                        try {
                            printJobPending = false; showPrintInstruction();
                            printIframe.contentWindow.print(); hideProcessing();
                            console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Print dialog should be open.');
                        } catch (printError) {
                            console.error('å°åˆ·ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', printError);
                            showError(`å°åˆ·ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${printError.message}`); hideProcessing();
                            if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
                        }
                    }
                };
                printIframe.onerror = (err) => { /* ... (å¤‰æ›´ãªã—) ... */
                     console.error('iframeèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
                     showError('å°åˆ·ç”¨PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); hideProcessing();
                     if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
                };
                printJobPending = true;
                printIframe.src = currentObjectUrl;
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Setting iframe src to:', currentObjectUrl);

            } catch (error) { /* ... (ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¤‰æ›´ãªã—) ... */
                console.error('å…¨ä½“å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                let message = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
                if (error instanceof PDFLib.PDFDocumentInvalidPasswordError) { message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ä¿è­·ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å‡¦ç†ã§ãã¾ã›ã‚“ã€‚'; }
                else if (error.message.includes('Invalid PDF structure') || error.name === 'InvalidPDFDataError') { message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ããªã„ã‹ã€ç ´æã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚'; }
                showError(message); hideProcessing();
                if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
            }
        }

        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° (å¤‰æ›´ãªã—) ---
        function showProcessing(message = 'å‡¦ç†ä¸­...') { /* ... */
            processingOverlay.querySelector('p').textContent = message;
            processingOverlay.classList.remove('hidden');
            document.body.style.cursor = 'wait';
        }
        function hideProcessing() { /* ... */
             processingOverlay.classList.add('hidden');
            document.body.style.cursor = 'default';
        }
        function showError(message, temporary = false) { /* ... */
            errorMessageDiv.textContent = message;
            if (temporary) { setTimeout(clearError, 3000); }
        }
        function clearError() { errorMessageDiv.textContent = ''; }
        function showPrintInstruction() { printInstruction.classList.remove('hidden'); }
        function hidePrintInstruction() { printInstruction.classList.add('hidden'); }

        // --- åˆæœŸåŒ–å‘¼ã³å‡ºã—ã€ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç† (å¤‰æ›´ãªã—) ---
        window.onload = initialize;
        window.addEventListener('beforeunload', () => {
            if (currentObjectUrl) {
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Revoking Object URL on page unload:', currentObjectUrl);
                URL.revokeObjectURL(currentObjectUrl);
            }
        });
    </script>
</body>
</html>
