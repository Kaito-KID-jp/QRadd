<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            font-size: 14px; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */
        }

        .container {
            display: flex;
            flex: 1;
            gap: 20px;
            min-height: 0; /* Flexboxã®å­è¦ç´ ãŒè¦ªã‚’è¶…ãˆãªã„ã‚ˆã†ã« */
        }

        .controls {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .preview {
            flex: 1;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto; /* ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¤§ãã„å ´åˆã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« */
            min-height: 0;
        }

        .preview canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; /* ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒ */
        }

        .preview-message {
            color: #666;
            text-align: center;
        }

        label {
            font-weight: bold;
        }

        input[type="text"] {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
        }

        button, input[type="file"] {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .file-input-button {
            background-color: #007bff;
            color: white;
            display: inline-block;
            text-align: center;
        }

        #printButton {
            background-color: #28a745;
            color: white;
        }
        #printButton:disabled {
            background-color: #6c757d;
        }

        .file-name {
            font-style: italic;
            color: #555;
            word-break: break-all;
        }

        .error-message {
            color: red;
            font-weight: bold;
            margin-top: 10px;
        }

        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            z-index: 1000;
            cursor: wait; /* å¾…æ©Ÿã‚«ãƒ¼ã‚½ãƒ« */
        }

        .hidden {
            display: none;
        }

        /* éè¡¨ç¤ºiframeç”¨ */
        .print-iframe {
            position: absolute;
            width: 0;
            height: 0;
            border: 0;
            left: -9999px;
        }

        .print-instruction {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            border-radius: 4px;
        }

    </style>
</head>
<body>

    <h1>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ </h1>

    <div class="container">
        <div class="controls">
            <div>
                <input type="file" id="pdfFile" accept=".pdf" class="hidden">
                <button type="button" class="file-input-button" onclick="document.getElementById('pdfFile').click();">ğŸ“‚ PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
                <p>é¸æŠä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«: <span id="fileName" class="file-name">ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ</span></p>
            </div>

            <div>
                <label for="lotNumber">âŒ¨ï¸ ãƒ­ãƒƒãƒˆç•ªå· :</label>
                <input type="text" id="lotNumber" pattern="^[a-zA-Z0-9\-]*$" title="åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿å…¥åŠ›å¯èƒ½ã§ã™">
            </div>

            <div>
                <button type="button" id="printButton" disabled>ğŸ–¨ï¸ å°åˆ· (QRã‚³ãƒ¼ãƒ‰è£é¢)</button>
                <p id="printInstruction" class="print-instruction hidden">
                    å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
                    <b>ã€Œä¸¡é¢å°åˆ·ã€</b>ã‚’é¸æŠã—ã€<b>ã€ŒçŸ­è¾ºã¨ã˜ (Flip on Short Edge / Top bind)ã€</b>ã«è¨­å®šã—ã¦å°åˆ·ã—ã¦ãã ã•ã„ã€‚
                </p>
            </div>

            <div id="errorMessage" class="error-message"></div>
        </div>

        <div class="preview" id="previewArea">
            <p class="preview-message">PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
            <canvas id="pdfPreviewCanvas"></canvas>
        </div>
    </div>

    <div id="processingOverlay" class="processing-overlay hidden">
        <p>å‡¦ç†ä¸­...</p>
    </div>

    <iframe id="printIframe" class="print-iframe"></iframe>

    <!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- pdf.js ã®èª­ã¿è¾¼ã¿ (ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // pdf.js workerã®è¨­å®š (CDNã‹ã‚‰èª­ã¿è¾¼ã‚€å ´åˆ)
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>

    <script>
        // --- è¨­å®šå€¤ ---
        const QR_PHYSICAL_SIZE_MM = 15;
        const QR_ERROR_CORRECTION_LEVEL = 'H'; // 'L', 'M', 'Q', 'H'
        const PDF_POINTS_PER_MM = 72 / 25.4; // 1ã‚¤ãƒ³ãƒ=72ãƒã‚¤ãƒ³ãƒˆ, 1ã‚¤ãƒ³ãƒ=25.4mm
        const QR_SIZE_POINTS = QR_PHYSICAL_SIZE_MM * PDF_POINTS_PER_MM;

        // --- DOMè¦ç´  ---
        const pdfFileInput = document.getElementById('pdfFile');
        const fileNameLabel = document.getElementById('fileName');
        const lotNumberInput = document.getElementById('lotNumber');
        const printButton = document.getElementById('printButton');
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('pdfPreviewCanvas');
        const previewMessage = previewArea.querySelector('.preview-message');
        const errorMessageDiv = document.getElementById('errorMessage');
        const processingOverlay = document.getElementById('processingOverlay');
        const printIframe = document.getElementById('printIframe');
        const printInstruction = document.getElementById('printInstruction');

        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let selectedPdfFile = null;
        let originalPdfFileName = '';
        let currentObjectUrl = null;

        // --- åˆæœŸåŒ– ---
        function initialize() {
            // ãƒ­ãƒƒãƒˆç•ªå·ã®åˆæœŸå€¤ã‚’è¨­å®š (yy-mm-dd)
            const today = new Date();
            const year = String(today.getFullYear()).slice(-2);
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            lotNumberInput.value = `${year}-${month}-${day}`;

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
            pdfFileInput.addEventListener('change', handleFileSelect);
            lotNumberInput.addEventListener('input', validateLotNumber);
            printButton.addEventListener('click', handlePrint);

            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†æç”» (ç°¡æ˜“ç‰ˆ)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (selectedPdfFile) {
                        displayPdfPreview(selectedPdfFile);
                    }
                }, 250); // 250mså¾…ã£ã¦ã‹ã‚‰ãƒªã‚µã‚¤ã‚ºå‡¦ç†
            });
        }

        // --- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠå‡¦ç† ---
        async function handleFileSelect(event) {
            clearError();
            hidePrintInstruction();
            const file = event.target.files[0];
            if (!file) {
                selectedPdfFile = null;
                fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ';
                printButton.disabled = true;
                clearPreview();
                return;
            }

            if (file.type !== 'application/pdf') {
                showError('PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                selectedPdfFile = null;
                fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ';
                printButton.disabled = true;
                clearPreview();
                pdfFileInput.value = ''; // å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢
                return;
            }

            selectedPdfFile = file;
            originalPdfFileName = file.name;
            fileNameLabel.textContent = originalPdfFileName;
            printButton.disabled = false;

            showProcessing('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...');
            try {
                await displayPdfPreview(selectedPdfFile);
            } catch (error) {
                console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                showError(`PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                clearPreview();
                printButton.disabled = true;
            } finally {
                hideProcessing();
            }
        }

        // --- PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º ---
        async function displayPdfPreview(file) {
            const fileReader = new FileReader();
            fileReader.readAsArrayBuffer(file);

            return new Promise((resolve, reject) => {
                fileReader.onload = async (event) => {
                    const pdfData = new Uint8Array(event.target.result);
                    try {
                        const loadingTask = pdfjsLib.getDocument({ data: pdfData });
                        const pdf = await loadingTask.promise;

                        if (pdf.numPages === 0) {
                           throw new Error('PDFã«ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                        }

                        const page = await pdf.getPage(1); // æœ€åˆã®ãƒšãƒ¼ã‚¸ã‚’å–å¾—

                        const viewport = page.getViewport({ scale: 1.5 }); // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è§£åƒåº¦èª¿æ•´
                        const canvasContext = previewCanvas.getContext('2d');

                        // Canvasã‚µã‚¤ã‚ºã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã«åˆã‚ã›ã‚‹ (ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒ)
                        const containerWidth = previewArea.clientWidth;
                        const containerHeight = previewArea.clientHeight;
                        const scale = Math.min(containerWidth / viewport.width, containerHeight / viewport.height);
                        const scaledViewport = page.getViewport({ scale: scale * 0.95 }); // å°‘ã—ãƒãƒ¼ã‚¸ãƒ³ã‚’æŒãŸã›ã‚‹

                        previewCanvas.height = scaledViewport.height;
                        previewCanvas.width = scaledViewport.width;

                        const renderContext = {
                            canvasContext: canvasContext,
                            viewport: scaledViewport
                        };
                        await page.render(renderContext).promise;

                        previewMessage.classList.add('hidden');
                        previewCanvas.classList.remove('hidden');
                        resolve();
                    } catch (error) {
                        console.error('PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                        reject(error);
                    }
                };
                fileReader.onerror = (error) => {
                    console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'));
                };
           });
        }

        function clearPreview() {
            const context = previewCanvas.getContext('2d');
            context.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCanvas.classList.add('hidden');
            previewMessage.textContent = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„';
            previewMessage.classList.remove('hidden');
        }

        // --- ãƒ­ãƒƒãƒˆç•ªå·ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ ---
        function validateLotNumber() {
            const lotNumber = lotNumberInput.value;
            // æ­£è¦è¡¨ç¾ã‚’ä¿®æ­£: ç©ºæ–‡å­—åˆ—ã‚‚è¨±å¯ã—ãªã„å ´åˆã¯ '+' ã‚’ä½¿ã†
            const pattern = /^[a-zA-Z0-9\-]+$/; // 1æ–‡å­—ä»¥ä¸Šã®è‹±æ•°å­—ãƒã‚¤ãƒ•ãƒ³
            if (!pattern.test(lotNumber) && lotNumber !== '') { // å…¥åŠ›é€”ä¸­ã¯è¨±å®¹ã™ã‚‹
                // ä¸æ­£ãªæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã€ãã‚Œã‚’å‰Šé™¤ã™ã‚‹ï¼ˆã‚ã‚‹ã„ã¯ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºï¼‰
                // lotNumberInput.value = lotNumber.replace(/[^a-zA-Z0-9\-]/g, ''); // è‡ªå‹•å‰Šé™¤ã¯å¥½ã¾ã—ããªã„å ´åˆã‚‚ã‚ã‚‹
                // showError('ãƒ­ãƒƒãƒˆç•ªå·ã«ã¯åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚', true); // ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼è¡¨ç¤º
                 return false; // ã‚¨ãƒ©ãƒ¼çŠ¶æ…‹ã‚’è¿”ã™
            }
            // clearError(); // æ­£ã—ã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼ã‚’æ¶ˆã™ï¼ˆä»–ã®ã‚¨ãƒ©ãƒ¼ã‚’æ¶ˆã•ãªã„ã‚ˆã†ã«æ³¨æ„ï¼‰
            return pattern.test(lotNumberInput.value); // æœ€çµ‚çš„ãªå€¤ã§ãƒã‚§ãƒƒã‚¯
        }

        // --- å°åˆ·å‡¦ç† ---
        // ***** ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ *****
        async function handlePrint() {
            if (!selectedPdfFile) {
                showError('ã¾ãšPDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            // ãƒ­ãƒƒãƒˆç•ªå·ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨å–å¾—
            const lotNumber = lotNumberInput.value;
            // å°åˆ·ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã«æœ€çµ‚ãƒã‚§ãƒƒã‚¯
            if (!/^[a-zA-Z0-9\-]+$/.test(lotNumber)) {
                 showError('ãƒ­ãƒƒãƒˆç•ªå·ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ (åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ã€ç©ºæ¬„ä¸å¯)ã€‚');
                 return;
            }

            showProcessing('QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨PDFåŠ å·¥ä¸­...');
            clearError();
            hidePrintInstruction();

            // â˜…â˜…â˜… ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã®è¿½åŠ ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ– â˜…â˜…â˜…
            try {
                // 1. QRã‚³ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
                const baseFileName = originalPdfFileName.replace(/\.[^/.]+$/, ""); // æ‹¡å¼µå­é™¤å»
                const firstPartFileName = baseFileName.split(' ')[0]; // æœ€åˆã®ã‚¹ãƒšãƒ¼ã‚¹ã¾ã§
                const qrData = `FXQR,1,dn,1,#d#,fn,${firstPartFileName}_${lotNumber},hs,1,at,0,RQXF`;
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR Data:', qrData); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                // 2. QRã‚³ãƒ¼ãƒ‰ç”»åƒç”Ÿæˆ (PNG Data URLã¨ã—ã¦)
                let qrCodeDataURL;
                try {
                    qrCodeDataURL = await QRCode.toDataURL(qrData, {
                        errorCorrectionLevel: QR_ERROR_CORRECTION_LEVEL.toLowerCase(),
                        type: 'image/png',
                        margin: 1,
                        scale: 8, // ååˆ†ãªè§£åƒåº¦ã‚’æŒãŸã›ã‚‹
                        color: { dark:"#000000", light:"#FFFFFF" }
                    });
                    console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR Code Data URL generated (first 100 chars):', qrCodeDataURL.substring(0, 100) + '...'); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                    if (!qrCodeDataURL || !qrCodeDataURL.startsWith('data:image/png')) {
                        throw new Error('ç”Ÿæˆã•ã‚ŒãŸData URLãŒç„¡åŠ¹ã§ã™ã€‚');
                    }
                } catch (qrError) {
                    console.error('QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', qrError);
                    throw new Error(`QRã‚³ãƒ¼ãƒ‰ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${qrError.message}`);
                }


                // 3. å…ƒã®PDFèª­ã¿è¾¼ã¿
                const pdfBytes = await selectedPdfFile.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes, {
                    // ignoreEncryption: true // å¿…è¦ã«å¿œã˜ã¦
                });
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original PDF loaded. Pages:', pdfDoc.getPageCount()); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                // 4. QRã‚³ãƒ¼ãƒ‰ç”»åƒã‚’åŸ‹ã‚è¾¼ã¿ç”¨ã«å¤‰æ›
                let qrImage;
                try {
                    const qrImageBytes = await fetch(qrCodeDataURL).then(res => {
                        if (!res.ok) throw new Error(`Failed to fetch QR code Data URL: ${res.statusText}`);
                        return res.arrayBuffer();
                    });
                    console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR Image Bytes fetched, length:', qrImageBytes.byteLength); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                    if (qrImageBytes.byteLength === 0) {
                         throw new Error('QRã‚³ãƒ¼ãƒ‰ç”»åƒã®ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚µã‚¤ã‚º0)ã€‚');
                    }
                    // pdf-libã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä»‹ã—ã¦ç”»åƒã‚’åŸ‹ã‚è¾¼ã‚€
                    qrImage = await pdfDoc.embedPng(qrImageBytes);
                    console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR Image embedded into PDF:', qrImage); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° (pdf-libã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒè¦‹ãˆã‚‹ã¯ãš)
                    if (!qrImage || !qrImage.ref) { // ç°¡å˜ãªãƒã‚§ãƒƒã‚¯
                         throw new Error('pdfDoc.embedPng ãŒæœ‰åŠ¹ãªç”»åƒã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
                    }
                } catch (embedError) {
                    console.error('Error embedding QR code image:', embedError);
                    throw new Error(`QRã‚³ãƒ¼ãƒ‰ç”»åƒã®åŸ‹ã‚è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${embedError.message}`);
                }

                // 5. æ–°ã—ã„PDFã‚’ä½œæˆã—ã€ãƒšãƒ¼ã‚¸ã¨QRã‚³ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                const newPdfDoc = await PDFLib.PDFDocument.create();
                const pageIndices = pdfDoc.getPageIndices();
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Calculated QR Size (points):', QR_SIZE_POINTS); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° (ç´„42.5ã®ã¯ãš)

                for (const pageIndex of pageIndices) {
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Processing page index: ${pageIndex}`); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                    // å…ƒã®ãƒšãƒ¼ã‚¸ã‚’ã‚³ãƒ”ãƒ¼
                    const [originalPage] = await newPdfDoc.copyPages(pdfDoc, [pageIndex]);
                    newPdfDoc.addPage(originalPage);
                    const originalPageSize = originalPage.getSize(); // ã‚µã‚¤ã‚ºã‚’å–å¾—
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original page ${pageIndex + 1} (size: ${originalPageSize.width}x${originalPageSize.height}) copied.`); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                    // QRã‚³ãƒ¼ãƒ‰ç”¨ã®æ–°ã—ã„ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ  (ã‚³ãƒ”ãƒ¼ã—ãŸãƒšãƒ¼ã‚¸ã®ã‚µã‚¤ã‚ºã‚’ä½¿ç”¨)
                    const qrPage = newPdfDoc.addPage([originalPageSize.width, originalPageSize.height]);
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR page added for page ${pageIndex + 1}.`); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                    // QRã‚³ãƒ¼ãƒ‰ã‚’å·¦ä¸‹ã«é…ç½®
                    try {
                         // å¿µã®ãŸã‚ã€qrImageã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã™ã‚‹ã‹å†ç¢ºèª
                        if (!qrImage || typeof qrImage.scale !== 'function') {
                             throw new Error('åŸ‹ã‚è¾¼ã¾ã‚ŒãŸQRç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ(qrImage)ãŒç„¡åŠ¹ã§ã™ã€‚æç”»ã§ãã¾ã›ã‚“ã€‚');
                        }
                        const qrDims = qrImage.scale(QR_SIZE_POINTS / qrImage.width); // ã‚µã‚¤ã‚ºèª¿æ•´ç”¨ãƒ¡ã‚½ãƒƒãƒ‰
                        console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Drawing QR code on page ${pageIndex + 1} at (0, 0) with size ${qrDims.width}x${qrDims.height}`); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                        // æç”»ã™ã‚‹ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
                        const drawWidth = QR_SIZE_POINTS;
                        const drawHeight = QR_SIZE_POINTS; // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã¯1:1ã®ã¯ãš

                        qrPage.drawImage(qrImage, {
                            x: 0, // å·¦ç«¯
                            y: 0, // ä¸‹ç«¯
                            width: drawWidth,
                            height: drawHeight,
                        });
                         console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: QR code drawn successfully for page ${pageIndex + 1}.`); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                    } catch (drawError) {
                         console.error(`Error drawing QR code on page ${pageIndex + 1}:`, drawError); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                         throw new Error(`QRã‚³ãƒ¼ãƒ‰ã®æç”»ã«å¤±æ•—ã—ã¾ã—ãŸ (ãƒšãƒ¼ã‚¸ ${pageIndex + 1}): ${drawError.message}`);
                    }
                }

                // 6. åŠ å·¥æ¸ˆã¿PDFã‚’ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿å­˜
                const newPdfBytes = await newPdfDoc.save({ useObjectStreams: true });
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: New PDF saved to bytes. Size:', newPdfBytes.byteLength); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

                // 7. Blobã¨Object URLã®ä½œæˆ
                const pdfBlob = new Blob([newPdfBytes], { type: 'application/pdf' });

                // ä»¥å‰ã®Object URLãŒã‚ã‚Œã°è§£æ”¾
                if (currentObjectUrl) {
                    URL.revokeObjectURL(currentObjectUrl);
                }
                currentObjectUrl = URL.createObjectURL(pdfBlob);

                // 8. éè¡¨ç¤ºiframeã§å°åˆ·
                let printJobPending = false; // å°åˆ·ã‚¸ãƒ§ãƒ–ãŒä¿ç•™ä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

                printIframe.onload = () => {
                    // src ãŒ blob URL ã§ã‚ã‚Šã€ã‹ã¤å°åˆ·ã‚¸ãƒ§ãƒ–ãŒä¿ç•™ä¸­ã®å ´åˆã®ã¿å®Ÿè¡Œ
                    if (printIframe.src && printIframe.src.startsWith('blob:') && printJobPending) {
                        try {
                            printJobPending = false; // å®Ÿè¡Œã™ã‚‹ã®ã§ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
                            showPrintInstruction(); // å°åˆ·æŒ‡ç¤ºã‚’è¡¨ç¤º
                            printIframe.contentWindow.print(); // å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
                            hideProcessing(); // å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰å‡¦ç†ä¸­è¡¨ç¤ºã‚’è§£é™¤
                            console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Print dialog should be open.'); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                        } catch (printError) {
                            console.error('å°åˆ·ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', printError);
                            showError(`å°åˆ·ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${printError.message}`);
                            hideProcessing();
                            if (currentObjectUrl) {
                                URL.revokeObjectURL(currentObjectUrl);
                                currentObjectUrl = null;
                            }
                        }
                    }
                };
                printIframe.onerror = (err) => {
                     console.error('iframeèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err);
                     showError('å°åˆ·ç”¨PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                     hideProcessing();
                     if (currentObjectUrl) {
                         URL.revokeObjectURL(currentObjectUrl);
                         currentObjectUrl = null;
                     }
                };

                // iframeã«srcã‚’è¨­å®šã™ã‚‹ç›´å‰ã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                printJobPending = true;
                printIframe.src = currentObjectUrl;
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Setting iframe src to:', currentObjectUrl); // â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°

            } catch (error) {
                console.error('å…¨ä½“å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error); // â˜…æ—¢å­˜ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ã«ã‚‚ãƒ­ã‚°è¡¨ç¤º
                let message = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
                if (error instanceof PDFLib.PDFDocumentInvalidPasswordError) { // PDFLibã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£
                    message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ä¿è­·ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å‡¦ç†ã§ãã¾ã›ã‚“ã€‚';
                } else if (error.message.includes('Invalid PDF structure') || error.name === 'InvalidPDFDataError') { // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§åˆ¤å®š
                    message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ããªã„ã‹ã€ç ´æã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚';
                }
                showError(message);
                hideProcessing();
                if (currentObjectUrl) {
                    URL.revokeObjectURL(currentObjectUrl);
                    currentObjectUrl = null;
                }
            }
        }
        // ***** ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ *****

        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---
        function showProcessing(message = 'å‡¦ç†ä¸­...') {
            processingOverlay.querySelector('p').textContent = message;
            processingOverlay.classList.remove('hidden');
            document.body.style.cursor = 'wait'; // bodyã«ã‚‚é©ç”¨
        }

        function hideProcessing() {
            processingOverlay.classList.add('hidden');
            document.body.style.cursor = 'default';
        }

        function showError(message, temporary = false) {
            errorMessageDiv.textContent = message;
            if (temporary) {
                setTimeout(clearError, 3000); // 3ç§’å¾Œã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¶ˆã™
            }
        }

        function clearError() {
            errorMessageDiv.textContent = '';
        }

        function showPrintInstruction() {
            printInstruction.classList.remove('hidden');
        }
        function hidePrintInstruction() {
            printInstruction.classList.add('hidden');
        }

        // --- ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«åˆæœŸåŒ– ---
        window.onload = initialize;

        // --- ãƒšãƒ¼ã‚¸ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰æ™‚ã«Object URLã‚’è§£æ”¾ ---
        window.addEventListener('beforeunload', () => {
            if (currentObjectUrl) {
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Revoking Object URL on page unload:', currentObjectUrl);
                URL.revokeObjectURL(currentObjectUrl);
            }
        });

    </script>

</body>
</html>
