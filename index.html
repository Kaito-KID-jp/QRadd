<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        /* CSSã¯å¤‰æ›´ãªã— */
        body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; font-size: 14px; }
        .container { display: flex; flex: 1; gap: 20px; min-height: 0; }
        .controls { width: 350px; display: flex; flex-direction: column; gap: 15px; }
        .preview { flex: 1; border: 1px solid #ccc; background-color: #f0f0f0; display: flex; justify-content: center; align-items: center; overflow: auto; min-height: 0; }
        .preview canvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        .preview-message { color: #666; text-align: center; }
        label { font-weight: bold; }
        input[type="text"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 100%; box-sizing: border-box; }
        button, input[type="file"] { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .file-input-button { background-color: #007bff; color: white; display: inline-block; text-align: center; }
        #printButton { background-color: #28a745; color: white; }
        #printButton:disabled { background-color: #6c757d; }
        .file-name { font-style: italic; color: #555; word-break: break-all; }
        .error-message { color: red; font-weight: bold; margin-top: 10px; }
        .processing-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255, 255, 255, 0.7); display: flex; justify-content: center; align-items: center; font-size: 1.2em; z-index: 1000; cursor: wait; }
        .hidden { display: none; }
        .print-iframe { position: absolute; width: 0; height: 0; border: 0; left: -9999px; }
        .print-instruction { margin-top: 10px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeeba; color: #856404; border-radius: 4px; }
        #downloadGeneratedPdfLink { display: block; margin-top: 15px; padding: 10px; border: 1px solid blue; background-color: #e0e0ff; color: blue; text-decoration: none; text-align: center; border-radius: 4px; }
        #downloadGeneratedPdfLink:hover { background-color: #c0c0ff; }
    </style>
</head>
<body>
    <h1>è£½é€ ä»•æ§˜æ›¸ï¼ˆå…¼ï¼‰ãƒã‚§ãƒƒã‚¯ã‚·ãƒ¼ãƒˆ ï¼±ï¼²ã‚³ãƒ¼ãƒ‰æŒ¿å…¥ã‚·ã‚¹ãƒ†ãƒ </h1>
    <div class="container">
        <div class="controls">
            <div>
                <input type="file" id="pdfFile" accept=".pdf" class="hidden">
                <button type="button" class="file-input-button" onclick="document.getElementById('pdfFile').click();">ğŸ“‚ PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
                <p>é¸æŠä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ«: <span id="fileName" class="file-name">ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ</span></p>
            </div>
            <div>
                <label for="lotNumber">âŒ¨ï¸ ãƒ­ãƒƒãƒˆç•ªå· :</label>
                <input type="text" id="lotNumber" pattern="^[a-zA-Z0-9\-]*$" title="åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿å…¥åŠ›å¯èƒ½ã§ã™">
            </div>
            <div>
                <button type="button" id="printButton" disabled>ğŸ–¨ï¸ å°åˆ· (QRã‚³ãƒ¼ãƒ‰è£é¢)</button>
                <p id="printInstruction" class="print-instruction hidden">
                    å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
                    <b>ã€Œä¸¡é¢å°åˆ·ã€</b>ã‚’é¸æŠã—ã€<b>ã€ŒçŸ­è¾ºã¨ã˜ (Flip on Short Edge / Top bind)ã€</b>ã«è¨­å®šã—ã¦å°åˆ·ã—ã¦ãã ã•ã„ã€‚
                </p>
            </div>
            <div id="errorMessage" class="error-message"></div>
        </div>
        <div class="preview" id="previewArea">
            <p class="preview-message">PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
            <canvas id="pdfPreviewCanvas"></canvas>
        </div>
    </div>
    <div id="processingOverlay" class="processing-overlay hidden">
        <p>å‡¦ç†ä¸­...</p>
    </div>
    <iframe id="printIframe" class="print-iframe"></iframe>

    <!-- ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿ (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>

    <script>
        // --- è¨­å®šå€¤ ---
        const QR_PHYSICAL_SIZE_MM = 15;
        const QR_ERROR_CORRECTION_LEVEL = 'H';
        const PDF_POINTS_PER_MM = 72 / 25.4;
        const QR_SIZE_POINTS = QR_PHYSICAL_SIZE_MM * PDF_POINTS_PER_MM;

        // --- DOMè¦ç´  ---
        const pdfFileInput = document.getElementById('pdfFile');
        const fileNameLabel = document.getElementById('fileName');
        const lotNumberInput = document.getElementById('lotNumber');
        const printButton = document.getElementById('printButton');
        const previewArea = document.getElementById('previewArea');
        const previewCanvas = document.getElementById('pdfPreviewCanvas');
        const previewMessage = previewArea.querySelector('.preview-message');
        const errorMessageDiv = document.getElementById('errorMessage');
        const processingOverlay = document.getElementById('processingOverlay');
        const printIframe = document.getElementById('printIframe');
        const printInstruction = document.getElementById('printInstruction');

        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
        let selectedPdfFile = null;
        let originalPdfFileName = '';
        let currentObjectUrl = null;

        // --- åˆæœŸåŒ–, ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ, ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º, ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ (å¤‰æ›´ãªã—) ---
        function initialize() { /* ... */ const today = new Date(); const year = String(today.getFullYear()).slice(-2); const month = String(today.getMonth() + 1).padStart(2, '0'); const day = String(today.getDate()).padStart(2, '0'); lotNumberInput.value = `${year}-${month}-${day}`; pdfFileInput.addEventListener('change', handleFileSelect); lotNumberInput.addEventListener('input', validateLotNumber); printButton.addEventListener('click', handlePrint); let resizeTimeout; window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (selectedPdfFile) { displayPdfPreview(selectedPdfFile); } }, 250); }); }
        async function handleFileSelect(event) { /* ... */ clearError(); hidePrintInstruction(); const existingLink = document.getElementById('downloadGeneratedPdfLink'); if (existingLink) { existingLink.remove(); } const file = event.target.files[0]; if (!file) { selectedPdfFile = null; fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ'; printButton.disabled = true; clearPreview(); return; } if (file.type !== 'application/pdf') { showError('PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); selectedPdfFile = null; fileNameLabel.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ'; printButton.disabled = true; clearPreview(); pdfFileInput.value = ''; return; } selectedPdfFile = file; originalPdfFileName = file.name; fileNameLabel.textContent = originalPdfFileName; printButton.disabled = false; showProcessing('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...'); try { await displayPdfPreview(selectedPdfFile); } catch (error) { console.error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error); showError(`PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`); clearPreview(); printButton.disabled = true; } finally { hideProcessing(); } }
        async function displayPdfPreview(file) { /* ... */ const fileReader = new FileReader(); fileReader.readAsArrayBuffer(file); return new Promise((resolve, reject) => { fileReader.onload = async (event) => { const pdfData = new Uint8Array(event.target.result); try { const loadingTask = pdfjsLib.getDocument({ data: pdfData }); const pdf = await loadingTask.promise; if (pdf.numPages === 0) throw new Error('PDFã«ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); const page = await pdf.getPage(1); const viewport = page.getViewport({ scale: 1.5 }); const canvasContext = previewCanvas.getContext('2d'); const containerWidth = previewArea.clientWidth; const containerHeight = previewArea.clientHeight; const scale = Math.min(containerWidth / viewport.width, containerHeight / viewport.height); const scaledViewport = page.getViewport({ scale: scale * 0.95 }); previewCanvas.height = scaledViewport.height; previewCanvas.width = scaledViewport.width; const renderContext = { canvasContext: canvasContext, viewport: scaledViewport }; await page.render(renderContext).promise; previewMessage.classList.add('hidden'); previewCanvas.classList.remove('hidden'); resolve(); } catch (error) { console.error('PDFãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error); reject(error); } }; fileReader.onerror = (error) => { console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error); reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚')); }; }); }
        function clearPreview() { /* ... */ if (previewCanvas && previewCanvas.getContext) { const context = previewCanvas.getContext('2d'); context.clearRect(0, 0, previewCanvas.width, previewCanvas.height); previewCanvas.classList.add('hidden'); } if (previewMessage) { previewMessage.textContent = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„'; previewMessage.classList.remove('hidden'); } }
        function validateLotNumber() { /* ... */ const lotNumber = lotNumberInput.value; const pattern = /^[a-zA-Z0-9\-]+$/; if (!pattern.test(lotNumber) && lotNumber !== '') { return false; } return pattern.test(lotNumberInput.value); }

        // --- å°åˆ·å‡¦ç† ---
        async function handlePrint() {
            if (!selectedPdfFile) { showError('ã¾ãšPDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); return; }
            const lotNumber = lotNumberInput.value;
            if (!/^[a-zA-Z0-9\-]+$/.test(lotNumber)) { showError('ãƒ­ãƒƒãƒˆç•ªå·ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„ (åŠè§’è‹±æ•°å­—ã¨ãƒã‚¤ãƒ•ãƒ³ã®ã¿ã€ç©ºæ¬„ä¸å¯)ã€‚'); return; }

            showProcessing('ãƒ†ã‚¹ãƒˆç”»åƒ(ä¸­å¤®)ç”Ÿæˆã¨PDFåŠ å·¥ä¸­...'); // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¤‰æ›´
            clearError();
            hidePrintInstruction();
            const existingLink = document.getElementById('downloadGeneratedPdfLink');
            if (existingLink) { existingLink.remove(); }

            try {
                // 1. QRã‚³ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ (ä»Šå›ã¯ä½¿ç”¨ã—ãªã„)

                // 2. ãƒ†ã‚¹ãƒˆç”¨PNGç”»åƒã®Data URLã‚’ç›´æ¥ä½¿ç”¨
                const testPngDataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Using Test PNG Data URL:', testPngDataURL);

                // 3. å…ƒã®PDFèª­ã¿è¾¼ã¿
                const pdfBytes = await selectedPdfFile.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original PDF loaded. Pages:', pdfDoc.getPageCount());

                // 4. ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã‚’åŸ‹ã‚è¾¼ã¿ç”¨ã«å¤‰æ›
                let testImage;
                try {
                    const testImageBytes = await fetch(testPngDataURL).then(res => { if (!res.ok) throw new Error(`Failed to fetch Test PNG Data URL: ${res.statusText}`); return res.arrayBuffer(); });
                    console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Test Image Bytes fetched, length:', testImageBytes.byteLength);
                    if (testImageBytes.byteLength === 0) throw new Error('ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã®ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ (ã‚µã‚¤ã‚º0)ã€‚');
                    testImage = await pdfDoc.embedPng(testImageBytes);
                    console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Test Image embedded into PDF:', testImage);
                    if (!testImage || !testImage.ref) throw new Error('pdfDoc.embedPng ãŒæœ‰åŠ¹ãªç”»åƒã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸ (ãƒ†ã‚¹ãƒˆç”¨)ã€‚');
                } catch (embedError) { console.error('Error embedding Test PNG image:', embedError); throw new Error(`ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã®åŸ‹ã‚è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${embedError.message}`); }

                // 5. æ–°ã—ã„PDFã‚’ä½œæˆã—ã€ãƒšãƒ¼ã‚¸ã¨ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã‚’è¿½åŠ 
                const newPdfDoc = await PDFLib.PDFDocument.create();
                const pageIndices = pdfDoc.getPageIndices();
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Target Draw Size (points):', QR_SIZE_POINTS);

                for (const pageIndex of pageIndices) {
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Processing page index: ${pageIndex}`);
                    const [originalPage] = await newPdfDoc.copyPages(pdfDoc, [pageIndex]);
                    newPdfDoc.addPage(originalPage);
                    const originalPageSize = originalPage.getSize();
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Original page ${pageIndex + 1} (size: ${originalPageSize.width}x${originalPageSize.height}) copied.`);
                    const addedPage = newPdfDoc.addPage([originalPageSize.width, originalPageSize.height]);
                    console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Test Image page added for page ${pageIndex + 1}.`);

                    // ***** ã“ã“ã‹ã‚‰ãŒå¤‰æ›´ç‚¹ *****
                    // ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã‚’æç”» (ä¸­å¤®ã«)
                    try {
                        if (!testImage || typeof testImage.scale !== 'function') throw new Error('åŸ‹ã‚è¾¼ã¾ã‚ŒãŸãƒ†ã‚¹ãƒˆç”¨ç”»åƒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹ã§ã™ã€‚æç”»ã§ãã¾ã›ã‚“ã€‚');

                        // ãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºå–å¾—
                        const pageSize = addedPage.getSize();
                        const pageWidth = pageSize.width;
                        const pageHeight = pageSize.height;

                        // scale() ã‚’ä½¿ã£ã¦ç›®æ¨™ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
                        const scaledDims = testImage.scale(QR_SIZE_POINTS / testImage.width);
                        console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Scaled Test Image dimensions: ${scaledDims.width.toFixed(2)} x ${scaledDims.height.toFixed(2)}`);

                        // â˜…â˜…â˜… æç”»ä½ç½®ã‚’ä¸­å¤®ã«å¤‰æ›´ â˜…â˜…â˜…
                        const drawX = (pageWidth - scaledDims.width) / 2;
                        const drawY = (pageHeight - scaledDims.height) / 2;
                        console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Drawing Test Image on page ${pageIndex + 1} at (${drawX.toFixed(2)}, ${drawY.toFixed(2)}) with scaled size`);

                        addedPage.drawImage(testImage, {
                            x: drawX, y: drawY,
                            width: scaledDims.width, height: scaledDims.height
                        });
                        console.log(`â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Test Image drawn attempt finished for page ${pageIndex + 1}.`);

                    } catch (drawError) {
                        console.error(`Error drawing Test Image on page ${pageIndex + 1}:`, drawError);
                        throw new Error(`ãƒ†ã‚¹ãƒˆç”¨ç”»åƒã®æç”»ã«å¤±æ•—ã—ã¾ã—ãŸ (ãƒšãƒ¼ã‚¸ ${pageIndex + 1}): ${drawError.message}`);
                    }
                    // ***** ã“ã“ã¾ã§ãŒå¤‰æ›´ç‚¹ *****
                }

                // 6. åŠ å·¥æ¸ˆã¿PDFã‚’ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ä¿å­˜
                const newPdfBytes = await newPdfDoc.save({ useObjectStreams: true });
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: New PDF saved to bytes. Size:', newPdfBytes.byteLength);

                // 7. Blobã¨Object URLã®ä½œæˆ
                const pdfBlob = new Blob([newPdfBytes], { type: 'application/pdf' });
                if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); }
                currentObjectUrl = URL.createObjectURL(pdfBlob);

                // 8. ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ä½œæˆ
                const downloadLink = document.createElement('a');
                downloadLink.id = 'downloadGeneratedPdfLink';
                downloadLink.href = currentObjectUrl;
                downloadLink.download = `test_png_center_${originalPdfFileName}`; // ãƒ•ã‚¡ã‚¤ãƒ«åå¤‰æ›´
                downloadLink.textContent = 'ç”Ÿæˆã•ã‚ŒãŸPDF(ãƒ†ã‚¹ãƒˆPNGä¸­å¤®ç‰ˆ)ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰'; // ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›´
                printButton.parentNode.insertBefore(downloadLink, printInstruction);
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Download link created for generated PDF (Test PNG Center).');

                // 9. éè¡¨ç¤ºiframeã§å°åˆ·
                let printJobPending = false;
                printIframe.onload = () => { if (printIframe.src && printIframe.src.startsWith('blob:') && printJobPending) { try { printJobPending = false; showPrintInstruction(); printIframe.contentWindow.print(); hideProcessing(); console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Print dialog should be open.'); } catch (printError) { console.error('å°åˆ·ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:', printError); showError(`å°åˆ·ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${printError.message}`); hideProcessing(); if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; } } } };
                printIframe.onerror = (err) => { console.error('iframeèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', err); showError('å°åˆ·ç”¨PDFã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); hideProcessing(); if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; } };
                printJobPending = true;
                printIframe.src = currentObjectUrl;
                console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Setting iframe src to:', currentObjectUrl);

            } catch (error) { /* ... (ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¤‰æ›´ãªã—) ... */ console.error('å…¨ä½“å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error); let message = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`; if (error instanceof PDFLib.PDFDocumentInvalidPasswordError) { message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ä¿è­·ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€å‡¦ç†ã§ãã¾ã›ã‚“ã€‚'; } else if (error.message.includes('Invalid PDF structure') || error.name === 'InvalidPDFDataError') { message = 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒæ­£ã—ããªã„ã‹ã€ç ´æã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚'; } showError(message); hideProcessing(); if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; } }
        }

        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° (å¤‰æ›´ãªã—) ---
        function showProcessing(message = 'å‡¦ç†ä¸­...') { processingOverlay.querySelector('p').textContent = message; processingOverlay.classList.remove('hidden'); document.body.style.cursor = 'wait'; }
        function hideProcessing() { processingOverlay.classList.add('hidden'); document.body.style.cursor = 'default'; }
        function showError(message, temporary = false) { errorMessageDiv.textContent = message; if (temporary) { setTimeout(clearError, 3000); } }
        function clearError() { errorMessageDiv.textContent = ''; }
        function showPrintInstruction() { printInstruction.classList.remove('hidden'); }
        function hidePrintInstruction() { printInstruction.classList.add('hidden'); }

        // --- åˆæœŸåŒ–å‘¼ã³å‡ºã—ã€ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç† (å¤‰æ›´ãªã—) ---
        window.onload = initialize;
        window.addEventListener('beforeunload', () => { if (currentObjectUrl) { console.log('â˜…ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°: Revoking Object URL on page unload:', currentObjectUrl); URL.revokeObjectURL(currentObjectUrl); } });
    </script>
</body>
</html>
